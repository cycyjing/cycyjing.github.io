(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{289:function(a,e,t){"use strict";t.r(e);var r=t(0),v=Object(r.a)({},function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"js-数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js-数据结构","aria-hidden":"true"}},[a._v("#")]),a._v(" JS 数据结构")]),a._v(" "),t("h2",{attrs:{id:"定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#定义","aria-hidden":"true"}},[a._v("#")]),a._v(" 定义")]),a._v(" "),t("p",[a._v("在计算机中，存储和组织数据的方式。在庞大的数据量中，高效的方式组织和存储。例如，大型图书馆，如何放书和取出。")]),a._v(" "),t("h2",{attrs:{id:"类别（详见-简书-coderwhy）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类别（详见-简书-coderwhy）","aria-hidden":"true"}},[a._v("#")]),a._v(" 类别（详见 简书 coderwhy）")]),a._v(" "),t("h3",{attrs:{id:"_1-数组-array"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-数组-array","aria-hidden":"true"}},[a._v("#")]),a._v(" 1. 数组 Array")]),a._v(" "),t("p",[a._v("是一种线性结构，并且可以在数组的任意位置插入和删除数据")]),a._v(" "),t("p",[a._v("缺点：")]),a._v(" "),t("p",[a._v("1）需要申请一段连续的内存空间（一整块内存），并且大小是固定的，如果不满足容量需求时，需要扩容")]),a._v(" "),t("p",[a._v("2）如果在数组开头或中间位置插入数据的成本很高，需要进行大量元素的位移")]),a._v(" "),t("h3",{attrs:{id:"_2-栈-stack："}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-栈-stack：","aria-hidden":"true"}},[a._v("#")]),a._v(" 2. 栈 Stack：")]),a._v(" "),t("p",[a._v("栈和队列是常见的受限的线性结构")]),a._v(" "),t("p",[a._v("栈顶 Top，栈底 Base")]),a._v(" "),t("p",[a._v("插入：进栈/入栈/压栈，只有一个进入口，顶开底封，LIFO")]),a._v(" "),t("p",[a._v("删除：退栈/出栈")]),a._v(" "),t("p",[a._v("例如，自助餐托盘，实体/电子信件")]),a._v(" "),t("p",[a._v("函数调用栈：A 调用 B，B 调用 C，C 调用 D")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("# 面试题\n有六个元素6,5,4,3,2,1的顺序进栈，问下列哪一个不是合法的出栈序列？（）\nA. 5 4 3 6 1 2\nB. 4 5 3 2 1 6\nC. 3 4 6 5 2 1\nD. 2 3 4 1 5 6\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br")])]),t("p",[a._v("实现方案：基于数组实现，基于链表实现")]),a._v(" "),t("h4",{attrs:{id:"常见方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常见方法","aria-hidden":"true"}},[a._v("#")]),a._v(" 常见方法")]),a._v(" "),t("p",[a._v("push(element)")]),a._v(" "),t("p",[a._v("pop()：移除栈顶的元素，同时返回移除的元素")]),a._v(" "),t("p",[a._v("peek()：返回栈顶的元素，不对栈做修改")]),a._v(" "),t("p",[a._v("isEmpty()")]),a._v(" "),t("p",[a._v("size()")]),a._v(" "),t("p",[a._v("toString()")]),a._v(" "),t("h3",{attrs:{id:"_3-队列-queue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-队列-queue","aria-hidden":"true"}},[a._v("#")]),a._v(" 3. 队列 Queue")]),a._v(" "),t("p",[a._v("队列也是常见的受限的线性结构，FIFO，受限之处在于，只允许在表的前端/front 进行删除，在表的后端/rear 进行插入")]),a._v(" "),t("p",[a._v("例如，买电影票，商场，厕所，文件打印，线程")]),a._v(" "),t("h4",{attrs:{id:"常用方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常用方法","aria-hidden":"true"}},[a._v("#")]),a._v(" 常用方法")]),a._v(" "),t("p",[a._v("enqueue(element)")]),a._v(" "),t("p",[a._v("dequeue()")]),a._v(" "),t("p",[a._v("front()")]),a._v(" "),t("p",[a._v("isEmpty()")]),a._v(" "),t("p",[a._v("size()")]),a._v(" "),t("p",[a._v("toString()")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("# 面试题 击鼓传花\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("h4",{attrs:{id:"常用实现类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常用实现类","aria-hidden":"true"}},[a._v("#")]),a._v(" 常用实现类")]),a._v(" "),t("h5",{attrs:{id:"优先级队列-priority-queue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优先级队列-priority-queue","aria-hidden":"true"}},[a._v("#")]),a._v(" - 优先级队列 Priority Queue")]),a._v(" "),t("p",[a._v("每个元素不再只是一个数据，而且包含数据的优先级。添加方式中，根据优先级放入正确位置。")]),a._v(" "),t("p",[a._v("例如，登记顺序，急症室")]),a._v(" "),t("p",[a._v("实现优先级队列主要考虑两个方面，")]),a._v(" "),t("p",[a._v("1）封装元素和优先级放在一起，可以封装一个新的构造函数")]),a._v(" "),t("p",[a._v("2）添加元素时，将新插入元素的优先级和队列中已经存在的元素优先级进行比较，以获得自己正确的位置")]),a._v(" "),t("h3",{attrs:{id:"_4-链表-linked-list"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-链表-linked-list","aria-hidden":"true"}},[a._v("#")]),a._v(" 4. 链表 Linked List")]),a._v(" "),t("p",[a._v("和数组一样，可以用于存储一系列元素，但是两个实现机制完全不同")]),a._v(" "),t("p",[a._v("不同于数组，链表中的元素在内存中不必时连续的空间，链表每一个元素由一个存储元素本身的节点和一个指向下一个元素的引用（有些语言称为指针或连接）组成")]),a._v(" "),t("p",[a._v("优点：")]),a._v(" "),t("p",[a._v("1）内存空间不是必须连续的")]),a._v(" "),t("p",[a._v("2）链表不必在创建就确定大小，并且大小可以无限的延伸")]),a._v(" "),t("p",[a._v("3）插入和删除数据时，时间复杂度可达 O(1)，相对数组效率高很多")]),a._v(" "),t("p",[a._v("缺点：")]),a._v(" "),t("p",[a._v("1）访问任何位置的元素，都需要从头开始访问")]),a._v(" "),t("p",[a._v("2）无法通过下标直接访问元素")]),a._v(" "),t("p",[a._v("例如，火车头连接车厢")]),a._v(" "),t("h4",{attrs:{id:"常见方法-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常见方法-2","aria-hidden":"true"}},[a._v("#")]),a._v(" 常见方法")]),a._v(" "),t("p",[a._v("append(element)：向列表尾部加一个新项")]),a._v(" "),t("p",[a._v("insert(position, element)：特定位置插入一个新项")]),a._v(" "),t("p",[a._v("get(position)")]),a._v(" "),t("p",[a._v("indexOf(element)：无该元素返回-1")]),a._v(" "),t("p",[a._v("update(position, element)")]),a._v(" "),t("p",[a._v("remove(element)")]),a._v(" "),t("p",[a._v("removeAt(position)")]),a._v(" "),t("p",[a._v("isEmpty()")]),a._v(" "),t("p",[a._v("size()")]),a._v(" "),t("p",[a._v("toString()")]),a._v(" "),t("h4",{attrs:{id:"双向链表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#双向链表","aria-hidden":"true"}},[a._v("#")]),a._v(" 双向链表")]),a._v(" "),t("p",[a._v("优点：从前往后，从后往前")]),a._v(" "),t("p",[a._v("缺点：插入 or 删除需要处理四个引用")]),a._v(" "),t("p",[a._v("方法在多两个")]),a._v(" "),t("p",[a._v("forwardString()")]),a._v(" "),t("p",[a._v("backwardString()")]),a._v(" "),t("h3",{attrs:{id:"_5-集合-set"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-集合-set","aria-hidden":"true"}},[a._v("#")]),a._v(" 5. 集合 Set")]),a._v(" "),t("p",[a._v("常见表现方式 Hash。集合通常是由一组无序的，不能重复的元素")]),a._v(" "),t("h4",{attrs:{id:"常见方法-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常见方法-3","aria-hidden":"true"}},[a._v("#")]),a._v(" 常见方法")]),a._v(" "),t("p",[a._v("add(value)")]),a._v(" "),t("p",[a._v("remove(value)")]),a._v(" "),t("p",[a._v("has(value)")]),a._v(" "),t("p",[a._v("clear()")]),a._v(" "),t("p",[a._v("size()")]),a._v(" "),t("p",[a._v("values()")]),a._v(" "),t("p",[a._v("集合间操作：并集，交集，差集(返回一个所有存在于 A 集合且不存在于 B 集合的元素的新集合)，子集")]),a._v(" "),t("h3",{attrs:{id:"_6-哈希表-散列表-hash"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-哈希表-散列表-hash","aria-hidden":"true"}},[a._v("#")]),a._v(" 6. 哈希表/散列表 Hash")]),a._v(" "),t("p",[a._v("哈希表通常是基于数组实现的，数组基于索引进行查找操作效率很高，但基于内容查找，插入和删除效率都不高。")]),a._v(" "),t("p",[a._v("相较于数组，哈希表有其优势：")]),a._v(" "),t("p",[a._v("1）可提供非常快速的插入，删除，查找操作")]),a._v(" "),t("p",[a._v("2）无论多少数据，插入和删除所需时间接近 O(1)。实际上，只需几个机器指令即可完成")]),a._v(" "),t("p",[a._v("3）速度比树还快，基本瞬间即可找到想要的元素")]),a._v(" "),t("p",[a._v("4）相对于树来说，代码要容易很多")]),a._v(" "),t("p",[a._v("不足：")]),a._v(" "),t("p",[a._v("1）数据是没有顺序的，所以不能以一种固定的方式（比如从小到大）来遍历其中的元素")]),a._v(" "),t("p",[a._v("2）通常情况下，哈希表中的 key 是不允许重复的")]),a._v(" "),t("h4",{attrs:{id:"冲突"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#冲突","aria-hidden":"true"}},[a._v("#")]),a._v(" 冲突")]),a._v(" "),t("p",[a._v("链地址法/拉链法： 每个数组单元中存储的不再是单个数据，而是一个链条（数组 or 链表）。在实际开发中，较常用，因为它不会因为添加了某个元素后性能急剧下降。")]),a._v(" "),t("p",[a._v("开放地址法： 主要工作方式是寻找空白的单元格来添加重复的数据。探测空白位置有三种方法，")]),a._v(" "),t("p",[a._v("1）线性探测：（插入）步长+1（查询）空位停止 （删除）内容不能设置为 null，进行特殊处理（例如设为-1），聚集（连续插入）问题用二次探测")]),a._v(" "),t("p",[a._v("2）二次探测：步长+n^2")]),a._v(" "),t("p",[a._v("3）再哈希法：stepSize = constant - (key % constant)")]),a._v(" "),t("p",[a._v("填装因子/load factor = 总数据项 / 哈希表长度，LF > 0.75 需要扩容，LF < 0.25 减少容量")]),a._v(" "),t("p",[a._v("优秀的哈希函数：快速计算（少乘除计算）--霍纳法则，均匀分布")]),a._v(" "),t("p",[a._v("质数/素数：一个数字若可以进行因数分解，那么分解时得到的两个数一定是一个小于等于 sqrt(n)，另一个大于等于 sqrt(n)，所以判断是否为质数，只需要遍历到 sqrt(n)平方根计算即可")]),a._v(" "),t("h3",{attrs:{id:"_7-树-tree"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-树-tree","aria-hidden":"true"}},[a._v("#")]),a._v(" 7. 树 Tree")]),a._v(" "),t("p",[a._v("弥补数组，链表，哈希表的不足，但是不能说树结构比其他结构都要好，因为每种数据结构都有自己特定的应用场景。")]),a._v(" "),t("h4",{attrs:{id:"常用术语"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常用术语","aria-hidden":"true"}},[a._v("#")]),a._v(" 常用术语")]),a._v(" "),t("p",[a._v("空树")]),a._v(" "),t("p",[a._v("根 Root")]),a._v(" "),t("p",[a._v("子树 Subtree")]),a._v(" "),t("p",[a._v("节点的度 Degree：节点的子树个数")]),a._v(" "),t("p",[a._v("树的度：树的所有节点中最大的度数")]),a._v(" "),t("p",[a._v("叶节点/叶子节点 Leaf：度为 0 的节点")]),a._v(" "),t("p",[a._v("路径和路径长度：从节点 n1 到 nk 的路径为一个节点序列 n1, n2, ... nk，ni 是 ni+1 的父节点。路径所包含边的个数为路径的长度")]),a._v(" "),t("p",[a._v("节点的层次 Level：规定根节点在 1 层，其他任意节点的层数是其父节点的层数+1")]),a._v(" "),t("p",[a._v("树的深度 Depth：树中所有节点中的最大层次")]),a._v(" "),t("p",[a._v("父节点 Parent")]),a._v(" "),t("p",[a._v("子节点 Child")]),a._v(" "),t("p",[a._v("兄弟节点 Sibling")]),a._v(" "),t("h4",{attrs:{id:"二叉树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二叉树","aria-hidden":"true"}},[a._v("#")]),a._v(" 二叉树")]),a._v(" "),t("h5",{attrs:{id:"特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特性","aria-hidden":"true"}},[a._v("#")]),a._v(" 特性")]),a._v(" "),t("p",[a._v("一个二叉树第 i 层的最大节点数为：2^(i-1), i>=1")]),a._v(" "),t("p",[a._v("深度为 k 的二叉树有最大节点总数为：2^k - 1, k>=1")]),a._v(" "),t("p",[a._v("对任何非空二叉树 T，若 n0 表示叶节点的个数、n2 是度为 2 的非叶节点个数，那么两者满足关系 n0=n2+1")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cycyjing.github.io/image/algorithm-tree1.PNG",alt:""}})]),a._v(" "),t("h5",{attrs:{id:"完美二叉树-perfect-binary-tree-满二叉树-full-binary-tree"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#完美二叉树-perfect-binary-tree-满二叉树-full-binary-tree","aria-hidden":"true"}},[a._v("#")]),a._v(" 完美二叉树 Perfect Binary Tree / 满二叉树 Full Binary Tree")]),a._v(" "),t("p",[a._v("除了最下一层的叶节点外，每层节点都有 2 个子节点。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cycyjing.github.io/image/algorithm-tree2.PNG",alt:""}})]),a._v(" "),t("h5",{attrs:{id:"完全二叉树-complete-binary-tree"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#完全二叉树-complete-binary-tree","aria-hidden":"true"}},[a._v("#")]),a._v(" 完全二叉树 Complete Binary Tree")]),a._v(" "),t("p",[a._v("除了最后一层外，其他各层的节点数都达到最大个数。且最后一层从左向右的节点连续存在，只缺右侧若干节点。完美二叉树是特殊的完全二叉树。")]),a._v(" "),t("h4",{attrs:{id:"二叉搜索树-二叉排序树-二叉查找树-binary-search-tree，bst"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二叉搜索树-二叉排序树-二叉查找树-binary-search-tree，bst","aria-hidden":"true"}},[a._v("#")]),a._v(" 二叉搜索树/二叉排序树/二叉查找树 Binary Search Tree，BST")]),a._v(" "),t("p",[a._v("如果不为空，满足以下性质：")]),a._v(" "),t("ul",[t("li",[a._v("非空左子树的所有键值小于其根节点的键值")]),a._v(" "),t("li",[a._v("非空右子树的所有键值大于其根节点的键值")]),a._v(" "),t("li",[a._v("左、右子树本身也是二叉搜索树")])]),a._v(" "),t("h5",{attrs:{id:"常用方法-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常用方法-2","aria-hidden":"true"}},[a._v("#")]),a._v(" 常用方法")]),a._v(" "),t("p",[a._v("insert(key)")]),a._v(" "),t("p",[a._v("search(key)")]),a._v(" "),t("p",[a._v("preorderTraversal：通过先序遍历方式遍历所有节点。访问根节点后先遍历其左子树再遍历右子树。头左右")]),a._v(" "),t("p",[a._v("inorderTraversal：通过中序遍历方式遍历所有节点。先遍历其左子树再访问根节点之后遍历右子树。左头右")]),a._v(" "),t("p",[a._v("postorderTraversal：通过后序遍历方式遍历所有节点。先遍历其左子树再遍历其右子树最后访问根节点。左右头")]),a._v(" "),t("p",[a._v("min()")]),a._v(" "),t("p",[a._v("max()")]),a._v(" "),t("p",[a._v("remove(key)：三种情况，1）该节点是叶节点；2）该节点有一个子节点；3）该节点有两个子节点")]),a._v(" "),t("h3",{attrs:{id:"图-graph"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#图-graph","aria-hidden":"true"}},[a._v("#")]),a._v(" 图 Graph")]),a._v(" "),t("h3",{attrs:{id:"堆-heap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆-heap","aria-hidden":"true"}},[a._v("#")]),a._v(" 堆 Heap")]),a._v(" "),t("h1",{attrs:{id:"算法-algorithm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#算法-algorithm","aria-hidden":"true"}},[a._v("#")]),a._v(" 算法 Algorithm")]),a._v(" "),t("h2",{attrs:{id:"定义-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#定义-2","aria-hidden":"true"}},[a._v("#")]),a._v(" 定义")]),a._v(" "),t("p",[a._v("input-有限的步骤约束-get output，解决问题的办法/步骤逻辑")])])},[],!1,null,null,null);e.default=v.exports}}]);